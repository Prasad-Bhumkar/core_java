//this file contains short notes of java programming

//====================================================================================================================================================================================================================================================================================


//***OOP CONCEPTS***

//Object-Oriented Programming (OOP) is a programming paradigm that revolves around the concept of objects and classes which have properties and methods.

//Object: An object is an instance of a class And real world entity which is represented by using class and object with the help of data members and member functions.

//*** Properties of object ***
//1. It has state Which holds current value of Attributes of an object.
//2. it has behaviour which defines how object act and react based on changing state or message passed to it.
//3. It has identity which is unique to each object.To identify object uniquely we select a single or group of attributes.
//4. It has responsibility which defines role of the object in the system in which it is present.

//====================================================================================================================================================================================================================================================================================


//*** There are four main Pillars of OOP *** 
//Abstraction, encapsulation, inheritance and polymorphism.

//1. Abstraction: It is process of selecting key aspects or attributes of an object according to current problems Scenario And hiding other details from user.
//Abstraction is achieved through abstract classes and interfaces, allowing for the exposure of only necessary information to the outside world while hiding internal implementation details.

//2. Encapsulation: It is a mechanism used to hide data, internal structure and implementation of object.Interaction with the object is provided through its public interface of operations.
//Encapsulation is achieved through classes, which wrap data and methods into a single unit, hiding internal implementation details from the outside world.

//3. Inheritance: It is a mechanism in which One object can acquire properties of another object.It helps to handle complexity through classification.User knows only about the interface. Any changes to the implementation will not affect the user.
//Inheritance is achieved through classes and interfaces, allowing one class to inherit the properties and behavior of another class.

//4. Polymorphism: The ability of different types of related objects to respond to the same message in their own way It's called as polymerism.A single command or method call can trigger different implementation and behaviour for the object upon which it is invoked.
//Polymorphism can be achieved through method overloading and method overriding, allowing objects of different classes to be treated as objects of a common superclass, and enabling more flexibility in programming.

//====================================================================================================================================================================================================================================================================================


//*** Types of relationships ***

//1. Is a : It is relationship between two objects or classes where one object is a subtype of another object. It is achieved by inheritance which have two perspectives generalisation and specialisation.

// generalisation :  It is a process of identifying common characteristics of a group of objects and representing them in a class.
// specialisation : It is a process of identifying a specific characteristic of a class and representing it in a subclass.


//2. Has a : It is relationship between two objects or classes where one Object is a part of another object.It is achieved by containment which have two perspectives composition and aggregation.

// Composition : Physical presence is necessary for the working of object.Because object is composed of these elements or attributes. 
// Aggregation : Physical presence is not necessary for the working of object.Object can still be working without these elements or attributes.


//==================================================================================================================================================================================================================================================================================


//***Features of Java***

//1.Platform independence: Java code can be compiled once and run anywhere.Bytecode can be transported on any operating system and hardware. Java is platform independent but strictly dependent upon jvm.

//2. Portable:  Java code can be easily moved from one environment to another without any changes.

//3. Simple: Java is a simple language to learn and use.

//4. Robust: Java is a robust language because it is designed to prevent errors and exceptions.

//5. Object-oriented: Java is an object-oriented language that supports the principles of encapsulation, inheritance, and polymorphism.

//6. Multithreaded: Java supports multithreading, which allows for concurrent execution of  multiple threads of execution.

//====================================================================================================================================================================================================================================================================================



//***Data types in Java***

//1. Primitive data types: These are the basic data types in Java, such as int, float, char, boolean, etc.
//   a. Byte: 8-bit signed integer, size: 1 byte
//   b. Short: 16-bit signed integer, size: 2 bytes
//   c. Int: 32-bit signed integer, size: 4 bytes
//   d. Long: 64-bit signed integer, size: 8 bytes
//   e. Float: 32-bit floating point number, size: 4 bytes
//   f. Double: 64-bit floating point number, size: 8 bytes
//   g. Char: 16-bit unsigned character, size: 2 bytes
//   h. Boolean: true or false value, size: 1 byte

//2. Non-Primitive data types: These are the data types that are used to store the memory address of an object, such as String, Array, etc.
//   a. Reference data types: These are the data types that are used to store the memory address of an object, such as String, Array, etc.
//   b. Wrapper classes: These are the classes that are used to convert primitive data types to objects, such as Integer, Float, etc.
//   c. Enumerations: These are the data types that are used to represent a fixed set of constants, such as Days, Colors, etc.
//   d. Arrays: These are the data types that are used to store a collection of values of the same data type, such as int[], String[], etc.
//   e. Collections: These are the data types that are used to store a collection of objects, such as ArrayList, LinkedList, etc.
//   f. Maps: These are the data types that are used to store a collection of key-value pairs, such as HashMap, TreeMap, etc.
//   g. Sets: These are the data types that are used to store a collection of unique values, such as HashSet, TreeSet, etc.
//   h. Generics: These are the data types that are used to store a collection of objects of a specific type, such as List<String>, Set<Integer>, etc.
//   i. Autoboxing and Unboxing: These are the features that are used to convert primitive data types to objects and vice versa, such as int to Integer, etc.


//====================================================================================================================================================================================================================================================================================


//***Execution of Java application in JVM***

//1. Compilation: The Java compiler (javac) compiles the Java source code into bytecode (.class file).
//   Source Code (.java) -> Compiler (javac) -> Bytecode (.class)

//2. Loading: The Class Loader loads the bytecode into memory.  
//   The Class Loader is responsible for loading the classes (Built in and user defined) and their dependencies into memory.
//   Bytecode (.class) -> Class Loader -> Runtime Data Areas

//3. Verification: The Bytecode Verifier checks the loaded bytecode for any errors and resolves any references to other classes or libraries.
//   Bytecode (.class) -> Bytecode Verifier -> Verified Bytecode

//4. Initialization: The JVM initializes the loaded classes by executing their static initializers.
//   Verified Bytecode -> JVM -> Initialized Classes

//5. Execution: The JVM executes the main method of the main class using the Interpreter.
//   Initialized Classes -> Interpreter -> Execution of main method

//6. Just-In-Time (JIT) Compilation: The JIT compiler compiles the frequently executed bytecode into native machine code.
//   Interpreter -> JIT Compiler -> Native Machine Code

//7. Execution of Native Machine Code: The JVM executes the native machine code.
//   Native Machine Code -> JVM -> Execution of Native Machine Code

//8. Runtime Data Areas: The JVM uses several runtime data areas to store data during execution, including:
//   a. Method Area: stores the class metadata, such as the class hierarchy and method tables.
//   b. Heap: stores the objects created by the application.
//   c. Stack: stores the thread's execution stack, including the method call stack and local variables.
//   d. Native Method Stack: stores the native method call stack.
//   e. PC Register: stores the current instruction pointer.
//   f. Native Method Interface: provides a way for Java code to call native methods.

//9. Garbage Collection: The JVM periodically runs the garbage collector to free up memory occupied by objects that are no longer referenced.

//10. Shutdown: The JVM shuts down when the application exits or when the JVM is explicitly shut down.


//====================================================================================================================================================================================================================================================================================


//*** JDK,JVM,JRE ***


//   JDK (Java Development Kit): a bundle of tools and libraries that are used to develop, compile, and run Java applications.
//   JVM (Java Virtual Machine): a runtime environment that executes Java bytecode.
//   JRE (Java Runtime Environment): a bundle of libraries and tools that are required to run Java applications, but not to develop them.


//   JRE = JVM + Libraries + Tools
//   JDK = JRE + Development Tools
//   JVM = JRE + Runtime Environment
//   JVM = JRE + Runtime Environment


//====================================================================================================================================================================================================================================================================================


//*** Access Specifiers in Java ***

// Access specifiers are used to define the scope of a class, method, or variable. They determine who can access the class, method, or variable.

// There are four types of access specifiers in Java:

// 1. Public: 
//   - Can be accessed from anywhere, both within and outside the class, and within and outside the package.
//   - Can be used with classes, methods, and variables.

// 2. Private: 
//   - Can only be accessed within the same class.
//   - Cannot be accessed from outside the class, not even from subclasses.
//   - Can be used with methods and variables.

// 3. Protected: 
//   - Can be accessed within the same class and from subclasses.
//   - Can also be accessed from classes within the same package.
//   - Can be used with methods and variables.

// 4. Default (no access specifier): 
//   - Can be accessed within the same class and from classes within the same package.
//   - Cannot be accessed from outside the package.
//   - Can be used with classes, methods, and variables.

// Example:

public class MyClass {
    public int publicVar;
    private int privateVar;
    protected int protectedVar;
    int defaultVar;

    public void myPublicMethod() {}
    private void myPrivateMethod() {}
    protected void myProtectedMethod() {}
    void myDefaultMethod() {}
}

// Accessing the variables and methods from within the same class:

public class MyClass {
    public void myMethod() {
        publicVar = 10; // accessible
        privateVar = 20; // accessible
        protectedVar = 30; // accessible
        defaultVar = 40; // accessible

        myPublicMethod(); // accessible
        myPrivateMethod(); // accessible
        myProtectedMethod(); // accessible
        myDefaultMethod(); // accessible
    }
}

// Accessing the variables and methods from a subclass:

public class MySubClass extends MyClass {
    public void myMethod() {
        publicVar = 10; // accessible
        // privateVar = 20; // not accessible
        protectedVar = 30; // accessible
        defaultVar = 40; // accessible

        myPublicMethod(); // accessible
        // myPrivateMethod(); // not accessible
        myProtectedMethod(); // accessible
        myDefaultMethod(); // accessible
    }
}

// Accessing the variables and methods from a class within the same package:

public class MyOtherClass {
    public void myMethod() {
        MyClass obj = new MyClass();
        obj.publicVar = 10; // accessible
        // obj.privateVar = 20; // not accessible
        // obj.protectedVar = 30; // not accessible
        obj.defaultVar = 40; // accessible

        obj.myPublicMethod(); // accessible
        // obj.myPrivateMethod(); // not accessible
        // obj.myProtectedMethod(); // not accessible
        obj.myDefaultMethod(); // accessible
    }
}

// Accessing the variables and methods from a class outside the package:

public class MyOtherClass {
    public void myMethod() {
        MyClass obj = new MyClass();
        obj.publicVar = 10; // accessible
        // obj.privateVar = 20; // not accessible
        // obj.protectedVar = 30; // not accessible
        // obj.defaultVar = 40; // not accessible

        obj.myPublicMethod(); // accessible
        // obj.myPrivateMethod(); // not accessible
        // obj.myProtectedMethod(); // not accessible
        // obj.myDefaultMethod(); // not accessible
    }
}

//  Accessing the variables and methods from a class In another package with inheritance

public class MyOtherClass extends MyClass {
    public void myMethod() {
        publicVar = 10; // accessible
        // privateVar = 20; // not accessible
        protectedVar = 30; // accessible
        defaultVar = 40; // accessible

        myPublicMethod(); // accessible
        // myPrivateMethod(); // not accessible
        myProtectedMethod(); // accessible
        myDefaultMethod(); // accessible
    }
}


//====================================================================================================================================================================================================================================================================================

//** this. keyword vs this() **
// this : keyword is used to refer to the current object of the class. It is used to access the members of the class and to call other methods of the class.

// this() : is a special method in Java that is used to call another constructor of the same class. It is used to initialize the objects of the class.

class MyClass {
    private int myVar;

    // No-arg Constructor
    public MyClass() {
        myVar = 0;
    }

    // Parameterized Constructor
    public MyClass(int myVar) {
        this.myVar = myVar;
    }

    // Constructor that calls another constructor using this()
    public MyClass(int myVar, int anotherVar) {
        this(myVar);
        System.out.println("Another variable: " + anotherVar);
    }

    // Method that uses this to refer to the current object
    public void myMethod() {
        System.out.println("Value of myVar: " + this.myVar);
    }

    public static void main(String[] args) {
        MyClass obj = new MyClass(10, 20);
        obj.myMethod();
    }
}

//====================================================================================================================================================================================================================================================================================


//** Constructor Chaining **
// Constructor chaining is a technique in which a constructor calls another constructor of the same class. 
// This is useful when we have multiple constructors in a class and we want to avoid code duplication.

class MyClass {
    private int myVar;

    // No-arg Constructor
    public MyClass() {
        this(0); // Calls the parameterized constructor with default value
    }

    // Parameterized Constructor
    public MyClass(int myVar) {
        this.myVar = myVar;
    }

    // Another Parameterized Constructor
    public MyClass(int myVar, int anotherVar) {
        this(myVar); // Calls the parameterized constructor with one parameter
        System.out.println("Another variable: " + anotherVar);
    }
}


//====================================================================================================================================================================================================================================================================================


//** static keyword **
// static keyword is used to create a class variable or a class method. Class variables are shared by
// all the objects of the class and class methods can be called without creating an object of the class.
// Static variables are initialized only once, at the start of the program, and they are stored in a
// single location in memory. Static methods can be used to perform operations that do not depend on
// the state of an object, such as mathematical calculations or data validation.

// Example:
class MyClass {
    private static int myStaticVar; // static variable

    public static void myStaticMethod() { // static method
        System.out.println("This is a static method");
    }

    public static void main(String[] args) {
        myStaticMethod(); // calling static method without creating an object
        System.out.println(myStaticVar); // accessing static variable without creating an object
    }
}


//====================================================================================================================================================================================================================================================================================


//**Accessor and Mutator Methods**

// Accessor Methods : These methods are used to get the value of a variable. They are also known as getter methods. They are used to return the value of a variable.
// Mutator Methods : These methods are used to set the value of a variable. They are also known as setter methods.

//Example : 
class MyClass {
    private int myVar;

    /**
     * Returns the value of myVar.
     * 
     * @return the value of myVar
     */
    public int getMyVar() {
        return myVar;
    }

    /**
     * Sets the value of myVar.
     * 
     * @param myVar the new value of myVar
     */
    public void setMyVar(int myVar) {
        this.myVar = myVar;
    }
}


//====================================================================================================================================================================================================================================================================================


//**Constructor And Destructor**


// Constructor : A constructor is a special method that is used to initialize the objects of a class when
// they are created. It has the same name as the class and does not have a return type.
// Destructor : Java does not have a destructor like some other languages. Instead, it has a finalize() method
// that is called by the garbage collector when it determines that an object is no longer reachable.

// Types of Constructors:
// 1. No-arg Constructor: A constructor with no parameters.
// 2. Parameterized Constructor: A constructor with parameters.
// 3. Copy Constructor: A constructor that creates a copy of an existing object.

// Constructor Overloading:
// Constructor overloading is a technique in which multiple constructors are defined with different parameters.

// Example:
class MyClass {
    private int myVar;

    // No-arg Constructor
    public MyClass() {
        myVar = 0;
    }

    // Parameterized Constructor
    public MyClass(int myVar) {
        this.myVar = myVar;
    }

    // Copy Constructor
    public MyClass(MyClass obj) {
        this.myVar = obj.myVar;
    }

    // finalize() method
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize() method called");
    }
}


//====================================================================================================================================================================================================================================================================================

//** Types of variables **


// 1. Instance Variables : These are the variables that are defined inside a class but outside any method. 
//They are also known as data members or Non-static . They are used to store the stateof an object.
// 2. Local Variables : These are the variables that are defined inside a method. 
// They are used to store temporary values that are used within the method. They are also known as method variables or formal parameters.
// 3. Static Variables : These are the variables that are shared by all objects of a class.
//They are used to store values that are common to all objects of a class. They are also called as class variables.


// 4. Final Variables : These are the variables that cannot be changed once they are
// initialized. They are used to store values that should not be changed once they are
// initialized.
// 5. Final Static Variables : These are the variables that are shared by all objects of a
// class and cannot be changed once they are initialized.
// 6. Class Variables : These are the variables that are shared by all objects of a class
// and are used to store values that are common to all objects of a class.
// 7. Instance Static Variables : These are the variables that are shared by all objects of a
// class and are used to store values that are common to all objects of a class.
// 8. Static Block Variables : These are the variables that are defined inside a static block
// and are used to store values that are common to all objects of a class.

// Example of Instance Variables
class MyClass {
    private int myVar; // instance variable

    public MyClass() {
        myVar = 0; // initializing instance variable
    }

    public void myMethod() {
        System.out.println("Value of myVar: " + myVar); // accessing instance variable
    }
}

// Example of Local Variables
class MyClass {
    public void myMethod() {
        int myVar = 0; // local variable
        System.out.println("Value of myVar: " + myVar); // accessing local variable
    }
}

// Example of Static Variables
class MyClass {
    private static int myVar; // static variable

    public static void myMethod() {
        System.out.println("Value of myVar: " + myVar); // accessing static variable
    }
}

// Example of Final Variables
class MyClass {
    private final int myVar = 0; // final variable

    public void myMethod() {
        System.out.println("Value of myVar: " + myVar); // accessing final variable
        // myVar = 10; // cannot change final variable
    }
}

// Example of Final Static Variables
class MyClass {
    private static final int myVar = 0; // final static variable

    public static void myMethod() {
        System.out.println("Value of myVar: " + myVar); // accessing final static variable
        // myVar = 10; // cannot change final static variable
    }
}

// Example of Class Variables
class MyClass {
    private static int myVar; // class variable

    public static void myMethod() {
        System.out.println("Value of myVar: " + myVar); // accessing class variable
    }
}

// Example of Instance Static Variables
class MyClass {
    private static int myVar; // instance static variable

    public void myMethod() {
        System.out.println("Value of myVar: " + myVar); // accessing instance static variable
    }
}

// Example of Static Block Variables
class MyClass {
    private static int myVar; // static block variable

    static {
        myVar = 0; // initializing static block variable
    }

    public static void myMethod() {
        System.out.println("Value of myVar: " + myVar); // accessing static block variable
    }
}

//====================================================================================================================================================================================================================================================================================

//** Static Block and Non-static Block **


// Static block is executed only once when the class is loaded into memory for the first time.
// Non-static block is executed every time an object of the class is created.

// Static block is used to initialize static variables and to perform other setup tasks that need to be done only once.
// Non-static block is used to initialize instance variables and to perform other setup tasks that need to be done every time an object is created.

// Example of Static Block
class MyClass {
    static {
        System.out.println("Static block executed");
    }
}

// Example of Non-static Block
class MyClass {
    {
        System.out.println("Non-static block executed");
    }
}

// Example of both Static and Non-static Blocks
class MyClass {
    static {
        System.out.println("Static block executed");
    }

    {
        System.out.println("Non-static block executed");
    }
}

// Output
// Static block executed
// Non-static block executed
// Non-static block executed

// Note: The static block is executed only once when the class is loaded into memory for the first time.
// The non-static block is executed every time an object of the class is created.


//====================================================================================================================================================================================================================================================================================


//**Passing Object To a Method**

// We can pass an object to a method in two ways : By Value and By Reference.

//Pass by value :- When we pass an object to a method by value, a copy of the object is passed to the method. Any changes made to the object inside the method will not affect the original object.
//Pass by reference :- When we pass an object to a method by reference, the original object is passed to the method. Any changes made to the object inside the method will affect the original object


class MyClass {
    private int myVar;

    /**
     * Returns the value of myVar.
     * 
     * @return the value of myVar
     */
    public int getMyVar() {
        return myVar;
    }

    /**
     * Sets the value of myVar.
     * 
     * @param myVar the new value of myVar
     */
    public void setMyVar(int myVar) {
        this.myVar = myVar;
    }

    public void myMethod(MyClass obj) {
        obj.setMyVar(10); // This will change the value of myVar in the original object.
    }

    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.setMyVar(5);
        obj.myMethod(obj);
        System.out.println(obj.getMyVar()); // This will print 10.
    }
}
//====================================================================================================================================================================================================================================================================================


//**toString() method **

// **toString() method is used to convert an object into a string. It is used to print the details of an object.
// The toString() method is called automatically when we use the print() or println() method to print an object. If we do not override the toString() method, it will print the class name of the object followed by @ and the hash code of the object.

//Example :-
class MyClass {
    private int myVar;
    private String myString;
    private double myDouble;
    private boolean myBoolean;
    private char myChar;

    public MyClass() {}

    public MyClass(int myVar, String myString, double myDouble, boolean myBoolean, char myChar) {
        this.myVar = myVar;
        this.myString = myString;
        this.myDouble = myDouble;
        this.myBoolean = myBoolean;
        this.myChar = myChar;
    }

    public int getMyVar() {
        return myVar;
    }

    public void setMyVar(int myVar) {
        this.myVar = myVar;
    }

    public String getMyString() {
        return myString;
    }

    public void setMyString(String myString) {
        this.myString = myString;
    }

    public double getMyDouble() {
        return myDouble;
    }

    public void setMyDouble(double myDouble) {
        this.myDouble = myDouble;
    }

    public boolean isMyBoolean() {
        return myBoolean;
    }

    public void setMyBoolean(boolean myBoolean) {
        this.myBoolean = myBoolean;
    }

    public char getMyChar() {
        return myChar;
    }

    public void setMyChar(char myChar) {
        this.myChar = myChar;
    }

    @Override
    public String toString() {
        return "MyClass{" +
                "myVar=" + myVar +
                ", myString='" + myString + '\'' +
                ", myDouble=" + myDouble +
                ", myBoolean=" + myBoolean +
                ", myChar=" + myChar +
                '}';
    }
}


//====================================================================================================================================================================================================================================================================================

//**  Meaning of public static void main(String[] args)  **//

// The main method is the entry point of a Java program. It is the method where the program starts execution.

// public: The main method is declared as public, which means it can be accessed from any other class.

// static: The main method is declared as static, which means it can be called without creating an instance of the class.

// void: The main method does not return any value, so it is declared as void.

// main: This is the name of the method.

// (String[] args): This is the parameter list of the main method. It takes an array of strings as arguments.

// The main method is used to start the execution of a Java program. It is called by the Java Virtual Machine (JVM) when the program is run.

// Here is an example of a simple main method:

public class MyClass {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// In this example, the main method is declared as public, static, and void. It takes an array of strings as arguments, but it does not use them in this case.

// When the program is run, the JVM calls the main method, which prints "Hello, World!" to the console.

// The main method can also be used to pass command-line arguments to the program. For example:

public class MyClass {
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println(arg);
        }
    }
}

// In this example, the main method takes an array of strings as arguments, and it prints each argument to the console.

// To pass command-line arguments to the program, you can use the following command:

// java MyClass arg1 arg2 arg3

// This will pass "arg1", "arg2", and "arg3" as arguments to the main method, which will print them to the console.

//====================================================================================================================================================================================================================================================================================

//** Method Overloading **
// Method overloading is a feature in Java that allows multiple methods with the same name to be defined, 
// as long as they have different parameter lists. This means that a class can have multiple methods with 
// the same name, but with different numbers or types of parameters.

// Example:
class MyClass {
    // Method to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Method to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Method to add two floats
    public float add(float a, float b) {
        return a + b;
    }

    public static void main(String[] args) {
        MyClass obj = new MyClass();
        System.out.println(obj.add(10, 20)); // Output: 30
        System.out.println(obj.add(10, 20, 30)); // Output: 60
        System.out.println(obj.add(10.5f, 20.5f)); // Output: 31.0
    }
}


//====================================================================================================================================================================================================================================================================================

//** Structure of memory in Java **

// In Java, memory is divided into several areas:

// 1. **Method Area**: This area stores the class metadata, such as the class hierarchy and method tables.
// 2. **Heap**: This area stores the objects created by the application.
// 3. **Stack**: This area stores the thread's execution stack, including the method call stack and local variables.
// 4. **Native Method Stack**: This area stores the native method call stack.
// 5. **PC Register**: This area stores the current instruction pointer.
// 6. **Native Method Interface**: This area provides a way for Java code to call native methods.

// The memory layout of a Java program can be visualized as follows:

// +---------------+
// |  Method Area  |
// +---------------+
// |  Heap         |
// +---------------+
// |  Stack        |
// +---------------+
// |  Native Method|
// |  Stack        |
// +---------------+
// |  PC Register  |
// +---------------+
// |  Native Method|
// |  Interface    |
// +---------------+

// The JVM manages the memory layout and ensures that the program executes correctly.

// The memory allocation process in Java can be summarized as follows:

// 1. The JVM allocates memory for the program's code and data.
// 2. The program creates objects, which are stored in the heap.
// 3. The program uses the stack to store local variables and method call information.
// 4. The program uses the native method stack to store native method call information.
// 5. The program uses the PC register to store the current instruction pointer.
// 6. The program uses the native method interface to call native methods.

// The JVM also performs garbage collection to free up memory occupied by objects that are no longer referenced.

// The garbage collection process can be summarized as follows:

// 1. The JVM identifies objects that are no longer referenced.
// 2. The JVM frees up the memory occupied by those objects.
// 3. The JVM compacts the heap to remove any holes created by the freed objects.

// The JVM also performs other memory management tasks, such as:

// 1. Memory allocation: The JVM allocates memory for the program's code and data.
// 2. Memory deallocation: The JVM frees up memory occupied by objects that are no longer referenced.
// 3. Memory compaction: The JVM compacts the heap to remove any holes created by the freed objects.
// 4. Memory defragmentation: The JVM defragments the heap to improve memory allocation efficiency.

// In summary, the JVM manages the memory layout and ensures that the program executes correctly by performing tasks such as memory allocation, garbage collection, and memory compaction.

//====================================================================================================================================================================================================================================================================================

//**Arrays in Java**

// Arrays are a collection of elements of the same data type stored in contiguous memory locations.

//**Types of Array Declaration**

// 1. Single Dimensional Array
int[] myArray;

// 2. Multi Dimensional Array
int[][] myArray;

// 3. Array of Arrays
int[] myArray[];

//**Types of Array Initialization**

// 1. Direct Initialization
int[] myArray = {1, 2, 3, 4, 5};

// 2. Indirect Initialization
int[] myArray;
myArray = new int[]{1, 2, 3, 4, 5};

// 3. Dynamic Initialization
int[] myArray = new int[5];
myArray[0] = 1;
myArray[1] = 2;
myArray[2] = 3;
myArray[3] = 4;
myArray[4] = 5;

//**Multi Dimensional Array Initialization**

// 1. Direct Initialization
int[][] myArray = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

// 2. Indirect Initialization
int[][] myArray;
myArray = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

// 3. Dynamic Initialization
int[][] myArray = new int[3][3];
myArray[0][0] = 1;
myArray[0][1] = 2;
myArray[0][2] = 3;
myArray[1][0] = 4;
myArray[1][1] = 5;
myArray[1][2] = 6;
myArray[2][0] = 7;
myArray[2][1] = 8;
myArray[2][2] = 9;

//**Example of Array Usage**

public class MyClass {
    public static void main(String[] args) {
        int[] myArray = {1, 2, 3, 4, 5};
        for (int i = 0; i < myArray.length; i++) {
            System.out.println(myArray[i]);
        }
    }
}

//====================================================================================================================================================================================================================================================================================

class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public class MyClass {
    public static void main(String[] args) {
        // Create an array of Student objects
        Student[] students = new Student[3];

        // Initialize the array with Student objects
        students[0] = new Student("John", 20);
        students[1] = new Student("Alice", 22);
        students[2] = new Student("Bob", 21);

        // Access and print the details of each Student object
        for (int i = 0; i < students.length; i++) {
            System.out.println("Name: " + students[i].getName() + ", Age: " + students[i].getAge());
        }
    }
}

//====================================================================================================================================================================================================================================================================================


// Definition of For Loop:
// A for loop is a control structure that allows you to execute a block of code repeatedly for a specified number of iterations.

// Definition of For Each Loop:
// A for-each loop is a type of for loop that allows you to iterate over a collection of elements, such as an array or a list, without having to keep track of the index.

// Syntax of For Loop:
// for (initialization; condition; increment/decrement) {
//     // code to be executed
// }

// Syntax of For Each Loop:
// for (type variable : collection) {
//     // code to be executed
// }

// For Loop with Enhanced Readability
public class MyClass {
    public static void main(String[] args) {
        int[] myArray = {1, 2, 3, 4, 5};
        for (int index = 0; index < myArray.length; index++) {
            int currentValue = myArray[index];
            System.out.println("Element at index " + index + ": " + currentValue);
        }
    }
}

// For Each Loop with Enhanced Readability
public class MyClass {
    public static void main(String[] args) {
        int[] myArray = {1, 2, 3, 4, 5};
        for (int element : myArray) {
            System.out.println("Current Element: " + element);
        }
    }
}


//====================================================================================================================================================================================================================================================================================
//====================================================================================================================================================================================================================================================================================
//====================================================================================================================================================================================================================================================================================
//====================================================================================================================================================================================================================================================================================
//====================================================================================================================================================================================================================================================================================
//====================================================================================================================================================================================================================================================================================
//====================================================================================================================================================================================================================================================================================
//====================================================================================================================================================================================================================================================================================
